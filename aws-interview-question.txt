ðŸ”¹ Ways Lambda A â†’ Lambda B Communication
1. Direct Invocation (via AWS SDK)

Lambda A can call Lambda B directly using the AWS SDK:

const AWS = require("aws-sdk");
const lambda = new AWS.Lambda();

exports.handler = async (event) => {
  const response = await lambda
    .invoke({
      FunctionName: "LambdaB", // name or ARN of Lambda B
      InvocationType: "RequestResponse", // sync
      Payload: JSON.stringify({ foo: "bar" }),
    })
    .promise();

  return JSON.parse(response.Payload);
};


InvocationType:

RequestResponse â†’ synchronous, waits for result.

Event â†’ async, just triggers B and returns immediately.

DryRun â†’ only checks if A is allowed to invoke B.

âœ… Pros: Simple, fast, no API Gateway needed.
âš ï¸ Cons: Tightly coupled (A must know Bâ€™s name/ARN). Works only inside AWS.

2. Through API Gateway (HTTP call)

Lambda B can be fronted by API Gateway.
Then Lambda A calls it using axios, fetch, etc.:

const fetch = require("node-fetch");

exports.handler = async () => {
  const response = await fetch("https://<api-id>.execute-api.us-east-1.amazonaws.com/dev/lambdaB", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ foo: "bar" }),
  });

  return await response.json();
};


âœ… Pros: Loose coupling, cross-service or cross-cloud friendly, built-in auth (Cognito/JWT).
âš ï¸ Cons: Slightly slower (API Gateway latency), you pay for API Gateway.

3. Event-Driven via SQS, SNS, or EventBridge

Instead of calling directly, Lambda A can publish an event/message:

SNS â†’ pub/sub, multiple Lambdas can subscribe.

SQS â†’ queue, guarantees delivery to Lambda B.

EventBridge â†’ routing rules, decoupled event-driven architecture.

Example with SNS:

const AWS = require("aws-sdk");
const sns = new AWS.SNS();

exports.handler = async () => {
  await sns.publish({
    TopicArn: "arn:aws:sns:us-east-1:123456789012:MyTopic",
    Message: JSON.stringify({ foo: "bar" }),
  }).promise();
};


Lambda B subscribes to that SNS topic â†’ it gets invoked automatically.

âœ… Pros: Very scalable, decoupled, async.
âš ï¸ Cons: Not suitable for synchronous request/response.

4. Step Functions (Workflow Orchestration)

If Lambda A and Lambda B are part of a workflow:

{
  "Comment": "Step Function example",
  "StartAt": "LambdaA",
  "States": {
    "LambdaA": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:us-east-1:123456789012:function:LambdaA",
      "Next": "LambdaB"
    },
    "LambdaB": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:us-east-1:123456789012:function:LambdaB",
      "End": true
    }
  }
}


âœ… Pros: Visual workflows, retries, error handling.
âš ï¸ Cons: More moving parts, added cost.

ðŸ”¹ Summary

Direct Invoke (AWS SDK) â†’ fastest, AWS-only, tight coupling.

API Gateway â†’ external clients + cross-service comms, looser coupling.

SNS/SQS/EventBridge â†’ async, decoupled, scalable.

Step Functions â†’ orchestration, retries, workflows.

âœ… So Lambda A can talk to Lambda B either synchronously (SDK/API Gateway) or asynchronously (SNS/SQS/EventBridge).


Ques : let suppose if I have microservice A => microservice B => microservice C => microservice D all are communicating sequentially if any one got failed we have to roll back my work entirely how I can do it in above case?
Ans : 
âœ… Summary:

    You solve rollback with Saga pattern (compensating transactions).
    In AWS â†’ best tool is Step Functions as an orchestrator.
    Alternative â†’ Event-driven choreography.


